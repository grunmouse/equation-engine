# Инструкция по использованию движка для парсинга и вычисления выражений

Этот движок (`equation-engine`) позволяет парсить математические выражения (формулы) с операторами, функциями и переменными, преобразовывать их в постфиксную нотацию (ПОЛИЗ) и вычислять. Он основан на алгоритме сортировочной станции (Shunting-yard) и стековой машине. Код состоит из модулей: `lexer.js` (токенизация), `shunting_yard.js` (преобразование в ПОЛИЗ), `handle.js` (промежуточная обработка конфликтов), `mashine.js` (вычисление) и главного `index.js` (сборка).

Движок гибкий: вы можете определять свои операторы, функции, переменные и типы значений. Ниже я объясню, как им пользоваться, с примерами на основе предоставленного кода.

## 1. Основные понятия
- **Парсер** (`createParser`): Преобразует строку-формулу в массив команд в ПОЛИЗ (постфиксной нотации).
- **Машина** (`createMashine`): Выполняет ПОЛИЗ, используя стек. Возвращает результат (или массив результатов, если стек не пуст).
- **Токены**: Литералы (числа, строки), переменные, операторы, функции.
- **ПОЛИЗ**: Форма, где операторы идут после операндов (например, `A B +` вместо `A + B`).

## 2. Импорт и настройка
Предполагаем, что модули (`lexer.js`, `shunting_yard.js`, `handle.js`, `mashine.js`) уже реализованы и доступны. Импортируйте движок:

```javascript
const eng = require('@grunmouse/equation-engine'); // Или ваш путь
```

## 3. Создание парсера
Парсер токенизирует формулу и преобразует в ПОЛИЗ. Создайте его с помощью `createParser(operators, functions, values, names)`.

### Параметры:
- **`operators`**: Объект с операторами. Ключи — символы операторов (например, `+`, `*`). Значения — объекты с:
  - `order`: Приоритет (число, выше — выше приоритет).
  - `arity`: Арность (число аргументов, по умолчанию 2 для бинарных).
  - `fix`: Тип ('prefix' для унарных, 'infix' для бинарных).
  - `right`: `true` для правоассоциативных (например, `**` для степени).
  - `sign`: Альтернативный символ (например, `^` как синоним `**`).
  - `com`: Команда для машины (если отличается от ключа).

- **`functions`**: Объект с функциями. Ключи — имена функций. Значения — объекты с `arity` (арность).

- **`values`**: Массив парсеров для литералов. Каждый элемент — массив `[regex, type, parser]`, где:
  - `regex`: Регулярное выражение для распознавания.
  - `type`: Тип (строка, например, 'number').
  - `parser`: Функция для преобразования строки в значение (например, `parseFloat`).

- **`names`**: Регулярное выражение для имён переменных (например, `/[A-Za-z_]+/`).

### Пример создания парсера (из кода):
```javascript
const starssetParser = eng.createParser(
    {
        '&': { order: 1 },  // Приоритет 1, бинарный
        '^': { order: 2 }   // Приоритет 2, бинарный
    },
    {},  // Нет функций
    [],  // Нет специальных литералов
    /[A-Za-z_А-Яа-яЁё]+/  // Имена переменных (с русскими буквами)
);
```

## 4. Создание машины
Машина выполняет ПОЛИЗ. Создайте её с помощью `createMashine(commands, getVariable, valueParsers={})`.

### Параметры:
- **`commands`**: Объект с реализациями операторов и функций. Ключи — имена команд (как в `operators` и `functions`). Значения — функции, принимающие аргументы и возвращающие результат.

- **`getVariable`**: Функция `(name) => value`, которая возвращает значение переменной по имени. Если переменная неизвестна, бросьте ошибку.

- **`valueParsers`**: Опциональный объект парсеров для типов литералов (если не указаны в `values` парсера).

### Пример создания машины (из кода):
```javascript
const starssetMashine = eng.createMashine(
    {
        '&': (a, b) => a[UNION](b),  // Реализация оператора &
        '^': (a, b) => a[INTERSECTION](b)  // Реализация оператора ^
    },
    (name) => {
        name = name.replace('_', ' ');  // Замена _ на пробел
        if (starssets.has(name)) {
            return starssets.get(name);
        } else {
            throw new Error(`Unknown starsset "${name}"`);
        }
    }
);
```

## 5. Использование
1. **Парсинг**: `let poliz = parser(строка_формулы);` — Получаете массив объектов (команды ПОЛИЗ).
2. **Вычисление**: `let result = mashine(poliz);` — Получаете результат. Если стек имеет несколько элементов, возвращается массив.

### Полный пример функции вычисления (из кода):
```javascript
function evalStarsset(str) {
    let p = starssetParser(str);  // Парсинг
    let res = starssetMashine(p);  // Вычисление
    return res;  // Результат
}

// Пример вызова:
let result = evalStarsset('Ursa_Major & Orion');  // Пересечение множеств звёзд
```

### Второй пример (сферические вычисления):
Парсер и машина для векторов, матриц и геометрии. Операторы: `+`, `-`, `*`, `/`, `**` (степень), `.` (скалярное произведение), унарный `-` (отрицание). Функции: `cross`, `abs`, `ort`, `angle`, `circle3P` и др.

```javascript
function evalSpheric(str) {
    let p = sphericParser(str);
    let res = sphericMashine(p);
    return res;
}

// Пример:
let vec = evalSpheric('A + B * 2');  // Векторы A и B из getVariable
```
